<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="Drone Commander.png">
    <title>Drone Commander</title>
    <style>
      body, html {
        margin: 0;
        padding: 0;
        height: 100%;
        font-family: sans-serif;
        overflow: hidden;
      }
      #container {
        display: flex;
        height: 100%;
        width: 100%;
      }
      #leftPanel {
        width: calc(100% - 500px);
        padding: 10px;
        box-sizing: border-box;
        background: #f0f0f0;
        overflow: auto;
      }
      #divider {
        width: 5px;
        background-color: #ccc;
        cursor: ew-resize;
      }
      #rightPanel {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        position: relative;
      }
      #rightPanel  button {
        font-size: 16px; 
        line-height: 1;
        padding: 5px 10px;
        margin:2px;
        vertical-align: middle;
        margin-right: 5px;
      }
      #webglContainer {
        flex: 3;
        position: relative;
        overflow: hidden;
        background: #ddd;
      }
      #statusPanel {
        flex: 1;
        background: #ddd;
        padding: 10px;
        overflow: auto;
        position: absolute;
        bottom: 0;
        width: 100%;
        height: 75px;
        font-size: 12px;
      }
      #statusPanel table {
        width: calc(100% - 50px);
      }
      #statusPanel input {
        width: 50px;
      }
      #blocklyDiv {
        height: calc(100% - 50px);
        width: 100%;
        border: 1px solid #ccc;
      }
      #menu {        
        margin-bottom: 10px;
      }
      #menu img {
        margin-top: -23px;
        margin-bottom: -23px;
      }
      button{
        margin-right:5px;
      }
      
      .blocklyTreeLabel {
        padding: 4px 8px;
        font-size: 16px;
        font-weight: bold;
        font-family: "Segoe UI", sans-serif;
      }

      .blocklyTreeRow {
        background: none !important; 
        border-radius: 0 !important;
        margin-bottom: 2px;
      }

      .blocklyTreeRow:hover {
        background-color: #e0e0e0 !important;
      }

      .blocklyToolboxCategory[data-category-id="logic"] > .blocklyTreeRow > .blocklyTreeLabel { color: #4B9CD3; }
      .blocklyToolboxCategory[data-category-id="loops"] > .blocklyTreeRow > .blocklyTreeLabel { color: #F7C948; }
      .blocklyToolboxCategory[data-category-id="math"] > .blocklyTreeRow > .blocklyTreeLabel { color: #F86624; }
      .blocklyToolboxCategory[data-category-id="text"] > .blocklyTreeRow > .blocklyTreeLabel { color: #8C6BB1; }
      .blocklyToolboxCategory[data-category-id="lists"] > .blocklyTreeRow > .blocklyTreeLabel { color: #3AAFB9; }
      .blocklyToolboxCategory[data-category-id="variables"] > .blocklyTreeRow > .blocklyTreeLabel { color: #FF8C42; }
      .blocklyToolboxCategory[data-category-id="functions"] > .blocklyTreeRow > .blocklyTreeLabel { color: #DB5461; }
      .blocklyToolboxCategory[data-category-id="drone"] > .blocklyTreeRow > .blocklyTreeLabel { color: #20A39E; }
      .blocklyToolboxCategory[data-category-id="sensors"] > .blocklyTreeRow > .blocklyTreeLabel { color: #90BE6D; }
      .blocklyToolboxCategory[data-category-id="flow"] > .blocklyTreeRow > .blocklyTreeLabel { color: #888888; }
      
    </style>
    <!-- Include Blockly -->
    <script src="libs/blockly_compressed.min.js"></script>
    <script src="libs/blocks_compressed.min.js"></script>
    <script src="libs/Msg/en.js"></script>
    <script src="libs/javascript_compressed.min.js"></script>
    <!-- Include Three.js -->
    <script src="libs/three.min.js"></script>
    <script src="libs/STLLoader.js"></script>  
    <script src="libs/MTLLoader.js"></script>  
    <script src="libs/OBJLoader.js"></script>  
    
  </head>
  <body>
    <div id="container">
      <div id="leftPanel">
        <div id="menu">
          <img src="Drone Commander.png" width="64px">    
          <select id="languageSelect">
            <option value="en">English</option>
            <option value="it">Italiano</option>
            <option value="fr">FranÃ§ais</option>
            <option value="de">Deutsch</option>
            <option value="es">EspaÃ±ol</option>
            <option value="pt">PortuguÃªs</option>
          </select>
          <button id="newBtn">New</button>
          <button id="loadBtn">Load</button>
          <button id="saveBtn">Save</button>
          <select id="scenarioSelect">
            <option value="">Scenari</option>
          </select>

          <input type="file" id="fileInput" style="display:none">
        </div>
        <div id="blocklyDiv"></div>
      </div>
      <div id="divider"></div>
      <div id="rightPanel">
        <div>  
          <button id="toggleWebglBtn" >ðŸ—–</button>  
          <button id="runBtn" ><font color='green'>â–¶</font></button>
          <button id="stopBtn" disabled ><font color='red'>â– </font></button>
        </div>
        <div id="webglContainer"></div>
        <div id="statusPanel">
          <table>
            <tr>
              <td>X:</td><td><input type="number" id="x" value="0" step="0.1"></td>
              <td>Z:</td><td><input type="number" id="z" value="0" step="0.1"></td>
            </tr>
            <tr>
              <td>Altitude:</td><td><input type="number" id="altitude" value="1.5" step="0.1"></td>
              <td>Direction:</td><td><input type="number" id="direction" value="0" step="1"></td>
            </tr>
            <tr>
              <td colspan="2">Status: <span id="flightStatus">On Ground</span></td>
            </tr>
          </table>
        </div>
      </div>
    </div>
    
    <script>
      // --- Definition of custom blocks ---
      function defineCustomBlocks(){
        Blockly.defineBlocksWithJsonArray([
          {
            "type": "take_off",
            "message0": Blockly.Msg["BKY_DRONE_TAKEOFF"],
            "previousStatement": null,
            "nextStatement": null,
            "colour": 20,
            "tooltip": Blockly.Msg["BKY_DRONE_TAKEOFF_TOOLTIP"]
          },
          {
            "type": "land",
            "message0": Blockly.Msg["BKY_DRONE_LAND"],
            "previousStatement": null,
            "nextStatement": null,
            "colour": 20,
            "tooltip": Blockly.Msg["BKY_DRONE_LAND_TOOLTIP"]
          },
          {
            "type": "set_altitude",
            "message0": Blockly.Msg["BKY_DRONE_SET_ALTITUDE"],
            "args0": [
              { "type": "input_value", "name": "ALTITUDE", "check": "Number" }
            ],
            "previousStatement": null,
            "nextStatement": null,
            "colour": 20,
            "tooltip": Blockly.Msg["BKY_DRONE_SET_ALTITUDE_TOOLTIP"]
          },
          {
            "type": "change_altitude",
            "message0": Blockly.Msg["BKY_DRONE_CHANGE_ALTITUDE"],
            "args0": [
              { "type": "input_value", "name": "ALTITUDE", "check": "Number" }
            ],
            "previousStatement": null,
            "nextStatement": null,
            "colour": 20,
            "tooltip": Blockly.Msg["BKY_DRONE_CHANGE_ALTITUDE_TOOLTIP"]
          },
          {
            "type": "set_angle",
            "message0": Blockly.Msg["BKY_DRONE_SET_ANGLE"],
            "args0": [
              { "type": "input_value", "name": "ANGLE", "check": "Number" }
            ],
            "previousStatement": null,
            "nextStatement": null,
            "colour": 20,
            "tooltip": Blockly.Msg["BKY_DRONE_SET_ANGLE_TOOLTIP"]
          },
          {
            "type": "change_angle",
            "message0": Blockly.Msg["BKY_DRONE_CHANGE_ANGLE"],
            "args0": [
              { "type": "input_value", "name": "ANGLE", "check": "Number" }
            ],
            "previousStatement": null,
            "nextStatement": null,
            "colour": 20,
            "tooltip": Blockly.Msg["BKY_DRONE_CHANGE_ANGLE_TOOLTIP"]
          },
          {
            "type": "slide",
            "message0": Blockly.Msg["BKY_DRONE_SLIDE"],
            "args0": [
              { "type": "input_value", "name": "SLIDE", "check": "Number" }
            ],
            "previousStatement": null,
            "nextStatement": null,
            "colour": 20,
            "tooltip": Blockly.Msg["BKY_DRONE_SLIDE_TOOLTIP"]
          },
          {
            "type": "walk",
            "message0": Blockly.Msg["BKY_DRONE_WALK"],
            "args0": [
              { "type": "input_value", "name": "DIST", "check": "Number" }
            ],
            "previousStatement": null,
            "nextStatement": null,
            "colour": 20,
            "tooltip": Blockly.Msg["BKY_DRONE_WALK_TOOLTIP"]
          },
          {
            "type": "wait",
            "message0": Blockly.Msg["BKY_DRONE_WAIT"],
            "args0": [
              { "type": "input_value", "name": "DIST", "check": "Number" }
            ],
            "previousStatement": null,
            "nextStatement": null,
            "colour": 20,
            "tooltip": Blockly.Msg["BKY_DRONE_WAIT_TOOLTIP"]
          },
          {
            "type": "smoke",
            "message0": Blockly.Msg["BKY_DRONE_SMOKE"],
            "args0": [
              { "type": "input_value", "name": "SMOKE", "check": "Boolean" }
            ],
            "previousStatement": null,
            "nextStatement": null,
            "colour": 20,
            "tooltip": Blockly.Msg["BKY_DRONE_SMOKE_TOOLTIP"]
          },
          {
            "type": "set_speed",
            "message0": Blockly.Msg["BKY_DRONE_SPEED"],
            "args0": [
              { "type": "input_value", "name": "SPEED", "check": "Number" }
            ],
            "previousStatement": null,
            "nextStatement": null,
            "colour": 20,
            "tooltip": "Imposta la velocitÃ  di avanzamento del drone"
          },          
          {
            "type": "sensor_keypressed",
            "message0": Blockly.Msg["BKY_SENSOR_KEYPRESSED"],
            "args0": [
              {
                "type": "field_dropdown",
                "name": "KEY",
                "options": [
                  [Blockly.Msg["ARROW_UP"], "ARROW_UP"], [Blockly.Msg["ARROW_DOWN"], "ARROW_DOWN"],
                  [Blockly.Msg["ARROW_LEFT"], "ARROW_LEFT"], [Blockly.Msg["ARROW_RIGHT"], "ARROW_RIGHT"],
                  [Blockly.Msg["SPACE"], "SPACE"], [Blockly.Msg["RETURN"], "RETURN"],
                  ["A", "A"], ["B", "B"], ["C", "C"], ["D", "D"],
                  ["E", "E"], ["F", "F"], ["G", "G"], ["H", "H"],
                  ["I", "I"], ["J", "J"], ["K", "K"], ["L", "L"],
                  ["M", "M"], ["N", "N"], ["O", "O"], ["P", "P"],
                  ["Q", "Q"], ["R", "R"], ["S", "S"], ["T", "T"],
                  ["U", "U"], ["V", "V"], ["W", "W"], ["X", "X"],
                  ["Y", "Y"], ["Z", "Z"]
                ]
              }
            ],
            "output": "Boolean",
            "colour": 90,
            "tooltip": Blockly.Msg["BKY_SENSOR_KEYPRESSED_TOOLTIP"],
            "helpUrl": ""
          },
          {
            "type": "sensor_x",
            "message0": Blockly.Msg["BKY_SENSOR_X"],
            "output": "Numeric",
            "colour": 90,
            "tooltip": Blockly.Msg["BKY_SENSOR_X_TOOLTIP"],
            "helpUrl": ""
          },
          {
            "type": "sensor_z",
            "message0": Blockly.Msg["BKY_SENSOR_Z"],
            "output": "Numeric",
            "colour": 90,
            "tooltip": Blockly.Msg["BKY_SENSOR_Z_TOOLTIP"],
            "helpUrl": ""
          },
          {
            "type": "sensor_altitude",
            "message0": Blockly.Msg["BKY_SENSOR_ALTITUDE"],
            "output": "Numeric",
            "colour": 90,
            "tooltip": Blockly.Msg["BKY_SENSOR_ALTITUDE_TOOLTIP"],
            "helpUrl": ""
          },
          {
            "type": "sensor_direction",
            "message0": Blockly.Msg["BKY_SENSOR_DIRECTION"],
            "output": "Numeric",
            "colour": 90,
            "tooltip": Blockly.Msg["BKY_SENSOR_DIRECTION_TOOLTIP"],
            "helpUrl": ""
          },
          {
            "type": "sensor_speed",
            "message0": Blockly.Msg["BKY_SENSOR_SPEED"],
            "output": "Number",
            "colour": 90,
            "tooltip": Blockly.Msg["BKY_SENSOR_SPEED_TOOLTIP"],
            "helpUrl": ""
          },
          {
            "type": "start_block",
            "message0": "Start",
            "nextStatement": null,
            "colour": 60,
            "tooltip": Blockly.Msg["BKY_FLOW_START_TOOLTIP"],
            "hat": "cap"
          },
          {
            "type": "end_block",
            "message0": "End",
            "previousStatement": null,
            "colour": 0,
            "tooltip": Blockly.Msg["BKY_FLOW_END_TOOLTIP"]
          }
        ]);
      }

      const makecodeTheme = Blockly.Theme.defineTheme('makecode', {
        base: Blockly.Themes.Classic,
        blockStyles: {
          logic_blocks: { colourPrimary: "#4B9CD3" },
          loops_blocks: { colourPrimary: "#F7C948" },
          math_blocks: { colourPrimary: "#F86624" },
          text_blocks: { colourPrimary: "#8C6BB1" },
          list_blocks: { colourPrimary: "#3AAFB9" },
          variable_blocks: { colourPrimary: "#FF8C42" },
          procedure_blocks: { colourPrimary: "#DB5461" },
          drone_blocks: { colourPrimary: "#20A39E" },
          sensor_blocks: { colourPrimary: "#90BE6D" }
        },
        categoryStyles: {
          logic_category: { colour: "#4B9CD3" },
          loops_category: { colour: "#F7C948" },
          math_category: { colour: "#F86624" },
          text_category: { colour: "#8C6BB1" },
          lists_category: { colour: "#3AAFB9" },
          variables_category: { colour: "#FF8C42" },
          functions_category: { colour: "#DB5461" },
          drone_category: { colour: "#20A39E" },
          sensors_category: { colour: "#90BE6D" },
          flow_category: { colour: "#888" }
        },
        fontStyle: {
          family: 'Segoe UI, sans-serif',
          size: 14
        },
        componentStyles: {
          workspaceBackgroundColour: "#ffffff",
          toolboxBackgroundColour: "#eeeeee",
          toolboxForegroundColour: "#000000",
          flyoutBackgroundColour: "#f0f0f0",
          flyoutForegroundColour: "#000000",
          flyoutOpacity: 1,
          scrollbarColour: "#cccccc",
          insertionMarkerColour: "#000000",
          insertionMarkerOpacity: 0.3,
          cursorColour: "#d0d0d0"
        }
      });
      
      // --- Generators for custom blocks ---
      // --- Drone ---
      Blockly.JavaScript.forBlock['take_off'] = block => 'delay=510;drone.takeOff();\n';
      Blockly.JavaScript.forBlock['land'] = block => 'delay=1010;drone.land();\n';
      Blockly.JavaScript.forBlock['set_altitude'] = block => {
        var altitude = Blockly.JavaScript.valueToCode(block, 'ALTITUDE', Blockly.JavaScript.ORDER_ATOMIC) || '0';
        return 'delay=' + altitude + '* 52;drone.setAltitude(' + altitude + ');\n';
      };
      Blockly.JavaScript.forBlock['change_altitude'] = block => {
        var altitude = Blockly.JavaScript.valueToCode(block, 'ALTITUDE', Blockly.JavaScript.ORDER_ATOMIC) || '0';
        return 'delay=' + Math.abs(altitude.replace(/[()]/g,'')) + '* 52;drone.changeAltitude(' + altitude + ');\n';
      };
      Blockly.JavaScript.forBlock['set_angle'] = block => {
        var angle = Blockly.JavaScript.valueToCode(block, 'ANGLE', Blockly.JavaScript.ORDER_ATOMIC) || '0';
        return 'delay=505;drone.setAngle(' + angle + ');\n';
      };
      Blockly.JavaScript.forBlock['change_angle'] = block => {
        var angle = Blockly.JavaScript.valueToCode(block, 'ANGLE', Blockly.JavaScript.ORDER_ATOMIC) || '0';
        return 'delay=505;drone.changeAngle(' + angle + ');\n';
      };
      Blockly.JavaScript.forBlock['slide'] = block => {
        var slide = Blockly.JavaScript.valueToCode(block, 'SLIDE', Blockly.JavaScript.ORDER_ATOMIC) || '0';
        return 'delay=' + Math.abs(slide.replace(/[()]/g, '')) + '*52;drone.slide(' + slide + ');\n';
      };
      Blockly.JavaScript.forBlock['walk'] = block => {
        var dist = Blockly.JavaScript.valueToCode(block, 'DIST', Blockly.JavaScript.ORDER_ATOMIC) || '0';
        return 'delay=' + Math.abs(dist.replace(/[()]/g, '')) + '*52/drone.speed;drone.walk(' + dist + ');\n';
      };
      Blockly.JavaScript.forBlock['wait'] = block => {
        var dist = Blockly.JavaScript.valueToCode(block, 'DIST', Blockly.JavaScript.ORDER_ATOMIC) || '0';
        return 'delay='+ (dist *1000) +'\n';
      };
      Blockly.JavaScript.forBlock['smoke'] = block => {
        var smoke = Blockly.JavaScript.valueToCode(block, 'SMOKE', Blockly.JavaScript.ORDER_ATOMIC) || '0';
        return `drone.smoke = (${smoke});\n`;
      };
      Blockly.JavaScript.forBlock['set_speed'] = block => {
        var speed = Blockly.JavaScript.valueToCode(block, 'SPEED', Blockly.JavaScript.ORDER_ATOMIC) || '1';
        return `drone.speed = ${speed};\n`;
      };
      
      //--- Sensor ---
      Blockly.JavaScript.forBlock['sensor_keypressed'] = block => {
        var key = block.getFieldValue('KEY');
        var code = "isKeyPressed('" + key + "')";
        return [code, Blockly.JavaScript.ORDER_NONE];
      };
      Blockly.JavaScript.forBlock['sensor_x'] = block => {
        var code = "-drone.mesh.position.z.toFixed(2)";
        return [code, Blockly.JavaScript.ORDER_NONE];
      };
      Blockly.JavaScript.forBlock['sensor_z'] = block => {
        var code = "-drone.mesh.position.x.toFixed(2)";
        return [code, Blockly.JavaScript.ORDER_NONE];
      };
      Blockly.JavaScript.forBlock['sensor_altitude'] = block => {
        var code = "drone.altitude.toFixed(2)";
        return [code, Blockly.JavaScript.ORDER_NONE];
      };
      Blockly.JavaScript.forBlock['sensor_direction'] = block => {
        var code = "-drone.direction.toFixed(2)";
        return [code, Blockly.JavaScript.ORDER_NONE];
      };
      Blockly.JavaScript.forBlock['sensor_speed'] = block => {
        return ['drone.speed', Blockly.JavaScript.ORDER_NONE];
      };
      //floor
      Blockly.JavaScript.forBlock['start_block'] = block => '';
      Blockly.JavaScript.forBlock['end_block'] = block => '';

            
      // --- Global variables ---
      let workspace, scene, camera, renderer, drone;
      let isResizing = false;
      let run=false
      let delay=100;
      const collisionPadding = 1.4;
      const collisionRayStartHeight = 10000;
      const collisionRaycaster = new THREE.Raycaster();
      let collisionMeshes = [];
      let groundMeshes = [];
      const container = document.getElementById("container");
      const leftPanel = document.getElementById("leftPanel");
      const divider = document.getElementById("divider");
      const webglContainer = document.getElementById('webglContainer');
      webglContainer.addEventListener('contextmenu', e => e.preventDefault());
      let propellers = [];

      // --- Camera control ---
      let isRightMouseDown = false;
      let isLeftMouseDown = false;
      const defaultCameraOffset = new THREE.Vector3(0, 5, 10).multiplyScalar(2.5);
      const cameraOffset = defaultCameraOffset.clone();

      let prevMousePos = { x: 0, y: 0 };
      let cameraAngle = { x: 0, y: 0 };


      // --- Command Queue ---
      const commandQueue = [];
      const addCommand = cmdFunction => {
        commandQueue.push(cmdFunction);
        if (commandQueue.length === 1) processQueue();
      };
      const processQueue = () => {
        if (!commandQueue.length) return;
        const cmd = commandQueue.shift();
        cmd(processQueue);
      };
          
      const animateProperty = (setter, from, to, duration, onComplete) => {
        const startTime = performance.now();
        const step = timestamp => {
          const progress = Math.min((timestamp - startTime) / duration, 1);
          setter(from + (to - from) * progress);
          if (progress < 1) {
            requestAnimationFrame(step);
          } else if (onComplete) {
            onComplete();
          }
        };
        requestAnimationFrame(step);
      };

      const registerCollisionMesh = mesh => {
        if (!mesh || !mesh.isMesh || mesh.userData.noCollision) return;
        collisionMeshes.push(mesh);
      };

      const registerGroundMesh = mesh => {
        if (!mesh || !mesh.isMesh || mesh.userData.noCollision) return;
        groundMeshes.push(mesh);
      };

      const collectCollisionMeshes = root => {
        root.traverse(obj => registerCollisionMesh(obj));
      };

      const getHeightAt = (meshes, x, z) => {
        if (!meshes.length) return 0;
        collisionRaycaster.set(new THREE.Vector3(x, collisionRayStartHeight, z), new THREE.Vector3(0, -1, 0));
        const intersections = collisionRaycaster.intersectObjects(meshes, false);
        if (!intersections.length) return 0;
        return intersections[0].point.y;
      };

      const getSurfaceHeightAt = (x, z) => getHeightAt(collisionMeshes, x, z);
      const getGroundHeightAt = (x, z) => getHeightAt(groundMeshes, x, z);

      const getSafeAltitudeAt = (x, z) => getSurfaceHeightAt(x, z) + collisionPadding;

      const enforceTerrainCollision = () => {
        if (!drone || !drone.mesh || !collisionMeshes.length) return;
        const minAltitude = drone.flying
          ? getSafeAltitudeAt(drone.mesh.position.x, drone.mesh.position.z)
          : getGroundHeightAt(drone.mesh.position.x, drone.mesh.position.z) + collisionPadding;
        if (drone.mesh.position.y < minAltitude) {
          drone.mesh.position.y = minAltitude;
          drone.altitude = minAltitude;
          updateStatus();
        }
      };

      // --- Events for camera control ---
      webglContainer.addEventListener('contextmenu', e => e.preventDefault(), { passive: true });
      webglContainer.addEventListener('mousedown', e => {
        if (e.button === 2) isRightMouseDown = true;
        if (event.button === 1) {
          cameraAngle.x +=Math.PI/2;                    
        }
        if (e.button === 0){ 
          isLeftMouseDown = true;
          camera.position.set(4, 0, 4);
          cameraAngle.x = Math.PI/2;          
          cameraAngle.y = 0;          
        }
        prevMousePos.x = e.clientX;
        prevMousePos.y = e.clientY;
      }, { passive: true });
      document.addEventListener('mouseup', () => {
        isRightMouseDown = false;
        isLeftMouseDown = false;
      }, { passive: true });
      document.addEventListener('mousemove', e => {
        const dx = e.clientX - prevMousePos.x;
        const dy = e.clientY - prevMousePos.y;

        if (isRightMouseDown) {
          cameraAngle.x += dx * 0.01;
          cameraAngle.y = Math.min(Math.max(cameraAngle.y + dy * 0.01, -Math.PI/2), Math.PI/2);
        }
            
        if (isLeftMouseDown) {}
        
        prevMousePos.x = e.clientX;
        prevMousePos.y = e.clientY;
      }, { passive: true });
      webglContainer.addEventListener('wheel', e => {
        e.preventDefault();
        const zoomFactor = 1 + e.deltaY * 0.001;
        cameraOffset.multiplyScalar(zoomFactor);

        const minZoom = 5;
        const maxZoom = 1000;
        cameraOffset.clampLength(minZoom, maxZoom);
      }, { passive: true });      

      // --- Updating the WebGL canvas with debouncing ---
      const updateWebGLCanvas = () => {
        const containerWidth = webglContainer.clientWidth;
        const containerHeight = webglContainer.clientHeight;
        const DESIRED_ASPECT = 4 / 3;
        let newWidth, newHeight;
        if (containerWidth / containerHeight > DESIRED_ASPECT) {
          newHeight = containerHeight;
          newWidth = containerHeight * DESIRED_ASPECT;
        } else {
          newWidth = containerWidth;
          newHeight = containerWidth / DESIRED_ASPECT;
        }
        renderer.setSize(newWidth, newHeight);
        renderer.domElement.style.cssText = `
          width: ${newWidth}px;
          height: ${newHeight}px;
          position: absolute;
          left: ${(containerWidth - newWidth) / 2}px;
          top: 0px;
        `;
        camera.aspect = newWidth / newHeight;
        camera.updateProjectionMatrix();
      };
      let resizeTimeout;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(updateWebGLCanvas, 100);
      }, { passive: true });

      // --- Initialization of Blockly ---
      const initBlockly = () => {
        const toolbox = {
          "kind": "categoryToolbox",
          "contents": [
            { "kind": "category", "name": Blockly.Msg["BKY_CATEGORY_LOGIC"], "colour": "210", "categorId": "logic", "contents": [
                { "kind": "block", "type": "controls_if" },
                { "kind": "block", "type": "logic_compare" },
                { "kind": "block", "type": "logic_operation" },
                { "kind": "block", "type": "logic_negate" },
                { "kind": "block", "type": "logic_boolean" },
                { "kind": "block", "type": "logic_null" },
                { "kind": "block", "type": "logic_ternary" }
              ]
            },
            { "kind": "category", "name": Blockly.Msg["BKY_CATEGORY_LOOPS"], "colour": "120", "categorId": "loops", "contents": [
                { "kind": "block", "type": "controls_repeat_ext" },
                { "kind": "block", "type": "controls_whileUntil" },
                { "kind": "block", "type": "controls_for" },
                { "kind": "block", "type": "controls_forEach" },
                { "kind": "block", "type": "controls_flow_statements" }
              ]
            },
            { "kind": "category", "name": Blockly.Msg["BKY_CATEGORY_MATH"], "colour": "230", "categorId": "math", "contents": [
                { "kind": "block", "type": "math_number" },
                { "kind": "block", "type": "math_arithmetic" },
                { "kind": "block", "type": "math_single" },
                { "kind": "block", "type": "math_trig" },
                { "kind": "block", "type": "math_constant" },
                { "kind": "block", "type": "math_number_property" },
                { "kind": "block", "type": "math_round" },
                { "kind": "block", "type": "math_on_list" },
                { "kind": "block", "type": "math_modulo" },
                { "kind": "block", "type": "math_constrain" },
                { "kind": "block", "type": "math_random_int" },
                { "kind": "block", "type": "math_random_float" }
              ]
            },
            { "kind": "category", "name": Blockly.Msg["BKY_CATEGORY_TEXT"], "colour": "160", "categorId": "text", "contents": [
                { "kind": "block", "type": "text" },
                { "kind": "block", "type": "text_join" },
                { "kind": "block", "type": "text_append" },
                { "kind": "block", "type": "text_length" },
                { "kind": "block", "type": "text_isEmpty" },
                { "kind": "block", "type": "text_indexOf" },
                { "kind": "block", "type": "text_charAt" },
                { "kind": "block", "type": "text_getSubstring" },
                { "kind": "block", "type": "text_changeCase" },
                { "kind": "block", "type": "text_trim" },
                { "kind": "block", "type": "text_print" }
              ]
            },
            { "kind": "category", "name": Blockly.Msg["BKY_CATEGORY_LISTS"], "colour": "260", "categorId": "lists", "contents": [
                { "kind": "block", "type": "lists_create_with" },
                { "kind": "block", "type": "lists_repeat" },
                { "kind": "block", "type": "lists_length" },
                { "kind": "block", "type": "lists_isEmpty" },
                { "kind": "block", "type": "lists_indexOf" },
                { "kind": "block", "type": "lists_getIndex" },
                { "kind": "block", "type": "lists_setIndex" },
                { "kind": "block", "type": "lists_getSublist" },
                { "kind": "block", "type": "lists_split" },
                { "kind": "block", "type": "lists_sort" }
              ]
            },
            { "kind": "category", "name": Blockly.Msg["BKY_CATEGORY_VARIABLES"], "colour": "330", "categorId": "variables", "custom": "VARIABLE" },
            { "kind": "category", "name": Blockly.Msg["BKY_CATEGORY_FUNCTIONS"], "colour": "290", "categorId": "functions", "custom": "PROCEDURE" },
            { "kind": "category","name": Blockly.Msg["BKY_CATEGORY_SENSORS"],"colour": "90", "categorId": "sensors", "contents": [
                { "kind": "block", "type": "sensor_keypressed" },
                { "kind": "block", "type": "sensor_x" },
                { "kind": "block", "type": "sensor_z" },
                { "kind": "block", "type": "sensor_altitude" },
                { "kind": "block", "type": "sensor_direction" },
                { "kind": "block", "type": "sensor_speed" }
              ]
            },  
            { "kind": "category", "name": Blockly.Msg["BKY_CATEGORY_DRONE"], "colour": "20", "categorId": "drone", "contents": 
              [
                { "kind": "block", "type": "take_off" },
                { "kind": "block", "type": "land" },
                { "kind": "block", "type": "set_altitude" },
                { "kind": "block", "type": "change_altitude" },
                { "kind": "block", "type": "set_angle" },
                { "kind": "block", "type": "change_angle" },
                { "kind": "block", "type": "slide" },
                { "kind": "block", "type": "walk" },
                { "kind": "block", "type": "wait" },
                { "kind": "block", "type": "smoke" },
                { "kind": "block", "type": "set_speed" }

              ]
            },
            { "kind": "category", "name": "Flow", "colour": "60", "categorId": "flow", "contents": 
              [
                { "kind": "block", "type": "start_block" },
                { "kind": "block", "type": "end_block" }
              ]
            },
          ]
        };
        workspace = Blockly.inject('blocklyDiv', {
           toolbox,
           renderer: 'zelos',
           theme: Blockly.Themes.makecode 
        });
      };

      // --- Keypress handler ---
      var pressedKeys = {};
      document.addEventListener('keydown', function(event) {
        pressedKeys[event.key] = true;
      }, { passive: true });
      document.addEventListener('keyup', function(event) {
        pressedKeys[event.key] = false;
      }, { passive: true });
      function isKeyPressed(key) {
        const normalizedKey = key.toLowerCase(); 

        const keyMap = {
          "space": " ",
          "return": "Return",
          "arrow_up": "ArrowUp",
          "arrow_down": "ArrowDown",
          "arrow_left": "ArrowLeft",
          "arrow_right": "ArrowRight"
        };
        const keyToCheck = keyMap[normalizedKey] || normalizedKey;
        return !!pressedKeys[keyToCheck];
      }
      
      // --- Drone Sound ---

      let audioCtx = null;
      let droneBuffer = null;
      let droneSource = null;
      let gainNode = null;
      const basePlaybackRate = 1.0; 
      const defaultVolume = 0.05;

      let audioLoadPromise = null;

      function initAudio() {
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          
          gainNode = audioCtx.createGain();
          gainNode.gain.value = defaultVolume;
          gainNode.connect(audioCtx.destination);
          
          audioLoadPromise = fetch('sounds/drone.mp3')
            .then(response => response.arrayBuffer())
            .then(arrayBuffer => audioCtx.decodeAudioData(arrayBuffer))
            .then(buffer => {
                droneBuffer = buffer;
                console.log("Audio caricato correttamente");
            })
            .catch(err => console.error("Errore nel caricamento dell'audio:", err));
        }
      }

      function playDroneSound() {
        if (!audioLoadPromise) {
          console.error("initAudio non Ã¨ stato chiamato!");
          return;
        }
        audioLoadPromise.then(() => {
          if (!audioCtx || !droneBuffer) {
            console.error("Audio non inizializzato o buffer non caricato");
            return;
          }
          if (droneSource) {
            droneSource.stop();
            droneSource.disconnect();
          }
          droneSource = audioCtx.createBufferSource();
          droneSource.buffer = droneBuffer;
          droneSource.loop = true;
          
          droneSource.loopStart = 0;
          droneSource.loopEnd = droneBuffer.duration; 
          
          droneSource.playbackRate.value = basePlaybackRate;
          
          droneSource.connect(gainNode);
          droneSource.start();
        });
      }

      function stopDroneSound() {
        if (droneSource) {
          droneSource.stop();
          droneSource.disconnect();
          droneSource = null;
        }
      }

      function updateDroneSound(newPlaybackRate) {
        if (droneSource) {
          droneSource.playbackRate.value = newPlaybackRate;
        }
      }

function loadScenario(file) {
  resetScene();

  // Rimuove tutti gli oggetti tranne quelli marcati come 'keep'
        scene.children = scene.children.filter(child => child.userData.type === 'keep');
  collisionMeshes = [];
  groundMeshes = [];
  collectCollisionMeshes(scene);

  if (!file) {
    location.reload();
    return;
  }
  
  fetch('backgrounds/' + file)
    .then(response => {
      if (!response.ok) throw new Error(`HTTP error ${response.status}`);
      return response.json();
    })
    .then(data => {
      // --- CARICAMENTO TERRENO ---
      const textureName = data.groundTexture || 'grass.jpg';
      const hillHeight = data.hillHeight || 25; 

      const textureLoader = new THREE.TextureLoader();
      textureLoader.load(
        'textures/' + textureName,
        function(texture) {
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.anisotropy = 16;

          const planeSize = 4100;
          const textureSize = 1024;
          texture.repeat.set(planeSize / textureSize, planeSize / textureSize);

          // Rimuove terreni precedenti
          const oldPlanes = scene.children.filter(obj => obj.userData.ground);
          oldPlanes.forEach(p => {
            scene.remove(p);
            if (p.geometry) p.geometry.dispose();
            if (p.material) p.material.dispose();
          });
          collisionMeshes = [];
          groundMeshes = [];
          collectCollisionMeshes(scene);
          
          // --- IMPOSTAZIONI FOGLIA ---
          if (data.fog) {
            const color = new THREE.Color(data.fog.color || 0x87ceeb);
            const near = data.fog.near !== undefined ? data.fog.near : 200;
            const far = data.fog.far !== undefined ? data.fog.far : 2500;
            scene.fog = new THREE.Fog(color, near, far);
            scene.background = color;
          } else {
            // Se non specificato, usa il default
            const defaultColor = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(defaultColor, 200, 2500);
            scene.background = defaultColor;
          }

          // âœ… CREA la geometria con segmenti
          const geometry = new THREE.PlaneGeometry(planeSize, planeSize, 32, 32);
          //console.log(geometry);

          // âœ… MODIFICA le Z per creare colline
          const vertices = geometry.vertices;
          const radius = 200; // zona piatta di raggio 100 attorno a (0,0)

          for (let i = 0; i < vertices.length; i++) {
            const v = vertices[i];
            const distance = Math.sqrt(v.x * v.x + v.y * v.y);

            if (distance < radius) {
              v.z = 0; // zona piatta centrale
            } else {
              const rx = Math.random() * (1.0 - 0.001) + 0.001;
              const ry = Math.random() * (1.0 - 0.001) + 0.001;
              v.z = hillHeight * Math.sin(v.x * rx) * Math.cos(v.y * ry);
            }
          }
          geometry.computeFaceNormals();
          geometry.computeVertexNormals();

          // CREA il piano con materiale
          const planeMaterial = new THREE.MeshLambertMaterial({
            map: texture,
            bumpMap: texture,
            bumpScale: 0.6
          });

          const plane = new THREE.Mesh(geometry, planeMaterial);
          plane.rotation.x = -Math.PI / 2;
          plane.receiveShadow = true;
          plane.userData.type = 'keep';
          plane.userData.ground = true;
          scene.add(plane);
          registerCollisionMesh(plane);
          registerGroundMesh(plane);
          enforceTerrainCollision();
        },
        undefined,
        function(err) {
          console.error('Errore caricando la texture del terreno:', err);
        }
      );

      // --- CARICAMENTO OGGETTI OBJ/MTL ---
      if (!data.objects) return;

      data.objects.forEach(obj => {
        const mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('models/');
        mtlLoader.load(obj.material, materials => {
          materials.preload();

          const objLoader = new THREE.OBJLoader();
          objLoader.setMaterials(materials);
          objLoader.setPath('models/');
          objLoader.load(obj.model, object => {
            object.traverse(child => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                child.userData.type = 'scenario';
                registerCollisionMesh(child);
              }
            });

            const scale = obj.scale || 1;
            object.scale.set(scale, scale, scale);

            if (obj.position) {
              object.position.set(obj.position.x, obj.position.y, obj.position.z);
            }

            if (obj.rotation) {
              object.rotation.set(
                THREE.MathUtils.degToRad(obj.rotation.x || 0),
                THREE.MathUtils.degToRad(obj.rotation.y || 0),
                THREE.MathUtils.degToRad(obj.rotation.z || 0)
              );
            }

            scene.add(object);
          },
          undefined,
          err => console.warn(`âŒ OBJ "${obj.model}" non caricato:`, err));
        },
        err => console.warn(`âŒ MTL "${obj.material}" non caricato:`, err));
      });
    })
    .catch(err => console.error('Errore caricando lo scenario:', err));
}

      // --- Initialization of Three.js and drone configuration ---
      const initThree = () => {
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87ceeb, 200, 2500);
        scene.background = new THREE.Color(0x87ceeb);
        camera = new THREE.PerspectiveCamera(75, 4/3, 0.1, 1000000);
        camera.position.set(4, 0, 4);
        cameraAngle.x =Math.PI/2;
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        webglContainer.appendChild(renderer.domElement);
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // luce soffusa
        ambientLight.userData.type = 'keep';
        scene.add(ambientLight);


        const light = new THREE.DirectionalLight(0xffffff, 1.0);
        light.position.set(0, 100, 0);
        light.castShadow = true;
        light.userData.type = 'keep';
        scene.add(light);
        light.shadow.mapSize.set(8192, 8192);
        light.shadow.camera.near = 0.5;
        light.shadow.camera.far = 500;
        light.shadow.camera.left = -55;
        light.shadow.camera.right = 55;
        light.shadow.camera.top = 55;
        light.shadow.camera.bottom = -55;

        //sky sphere
        const geometry = new THREE.SphereGeometry(2000, 64, 64); // molto grande
        //geometry.scale(1, 1, 1); // inverti le normali
        const sky_texture = new THREE.TextureLoader().load('textures/sky_campo_di_volo.png');
        const material = new THREE.MeshBasicMaterial({ 
          map: sky_texture,
          side: THREE.BackSide
        });
        const skySphere = new THREE.Mesh(geometry, material);
        skySphere.userData.noCollision = true;
        skySphere.userData.type = 'keep';
        scene.add(skySphere);
        
        //plane
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load(
          'textures/grass.jpg',
          function(texture) {
            texture.wrapS = THREE.RepeatWrapping; 
            texture.wrapT = THREE.RepeatWrapping; 
            texture.anisotropy = 16; 

            const planeSize = 4100; 
            const textureSize = 256; 

            texture.repeat.set(planeSize / textureSize, planeSize / textureSize);

            const planeMaterial = new THREE.MeshLambertMaterial({
              map: texture,
              bumpMap: texture,
              bumpScale: 0.3
            });
                
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(planeSize, planeSize), planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            plane.userData.ground = true;
            registerCollisionMesh(plane);
            registerGroundMesh(plane);
            //plane.userData.type = 'keep';
            scene.add(plane);
          },
          undefined,
          function(err) {
            console.error('Error in texture download', err);
          }
        );
            
        const piattaformaLoader = new THREE.TextureLoader();
        piattaformaLoader.load(
          'textures/piattaforma.png',
          function(texture) {
            const planeMaterial = new THREE.MeshLambertMaterial({
              map: texture,
              transparent: true
            });
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(16, 16, 256, 256), planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y=0.3;
            plane.receiveShadow = true;
            registerCollisionMesh(plane);
            scene.add(plane);
            plane.userData.type = 'keep';
          },
          undefined,
          function(err) {
            console.error('Error in texture download', err);
          }
        );
            
        function addPropellers() {
          if (!drone.mesh) {
            console.error("Il drone non Ã¨ stato caricato, impossibile aggiungere le eliche!");
            return;
          }

          const loader = new THREE.STLLoader();
          loader.load('models/elica.stl', (propellerGeometry) => {
            //propellerGeometry.computeVertexNormals();  
            const propellerMaterial = new THREE.MeshPhongMaterial({ color: 0xFF0000 });
                  
            const positions = [
              { x:-580, z:-620 },  
              { x: 600, z:-600 }, 
              { x:-580, z: 630 },
              { x: 620, z: 620 } 
            ];

            drone.propellers = []; 

            positions.forEach((pos, index) => {
              const propeller = new THREE.Mesh(propellerGeometry, propellerMaterial);
              propeller.position.set(pos.x, 200.0, pos.z); 
              propeller.geometry.translate(0, -8, 0);
              propeller.userData.noCollision = true;

              drone.mesh.add(propeller);
              drone.propellers.push(propeller);
            });
          });
        }

        var object;
        const loader = new THREE.STLLoader();
        loader.load('models/drone.stl', (geometry) => {
          geometry.computeVertexNormals();  
          const material = new THREE.MeshPhongMaterial({ color: 0x404040 });
          const object = new THREE.Mesh(geometry, material);
          object.scale.set(0.005, 0.005, 0.005);
          object.position.set(0, 1.4, 0);
          object.castShadow = true;
          scene.add(object);

          drone.mesh = object;
          drone.mesh.userData.noCollision = true;
          drone.mesh.userData.type = 'keep';
          addPropellers();
        });

        drone = {
          mesh: object, 
          propellers: [],
          flying: false,
          altitude: 1.5,
          direction: 0,
          smoke: 0,
          speed: 1.0,
          takeOff(callback) {
            if (!this.flying) {
              addCommand(next => {
                this.flying = true;
                playDroneSound();
                const startAltitude = this.altitude;
                this.propellerInterval = setInterval(
                  () => {
                    if (this.propellers) {
                      this.propellers.forEach(
                        prop => {
                          prop.rotation.y += 2.00;
                        } 
                      );
                    }
                  }
                  , 16
                );
                animateProperty(
                  val => { 
                    this.mesh.position.y = val; this.altitude = val; updateStatus(); 
                  },
                  startAltitude, 10.0, 500,
                  () => { 
                    updateStatus(); next(); if (callback) callback(); 
                  }
                );
              });
            } else if (callback) callback();
          },
          land(callback) {
            if (this.flying) {
              addCommand(
                next => {
                  const startAltitude = this.altitude;
                  const targetAltitude = getSafeAltitudeAt(this.mesh.position.x, this.mesh.position.z);
                  animateProperty(
                    val => { 
                      const clampedAltitude = Math.max(val, targetAltitude);
                      this.mesh.position.y = clampedAltitude;
                      this.altitude = clampedAltitude;
                      updateStatus();
                    },
                    startAltitude, targetAltitude, 1000,
                    () => { 
                      this.flying = false;
                      clearInterval(this.propellerInterval); 
                      stopDroneSound();
                      updateStatus();
                      next();
                      if (callback) callback();
                    }
                  );
                }
              );
            } else if (callback) callback();
          },
          setAltitude(value, callback) {
            if (this.flying) {
              addCommand(next => {
                updateDroneSound(basePlaybackRate + 1.0);
                const startAltitude = this.altitude;
                const minAltitude = getSafeAltitudeAt(this.mesh.position.x, this.mesh.position.z);
                const targetAltitude = Math.max(value, minAltitude);
                animateProperty(
                  val => { 
                    const clampedAltitude = Math.max(val, minAltitude);
                    this.mesh.position.y = clampedAltitude;
                    this.altitude = clampedAltitude;
                    updateStatus();
                  },
                  startAltitude, targetAltitude, Math.abs(targetAltitude - startAltitude) * 50,
                  () => { 
                    updateDroneSound(basePlaybackRate);
                    next(); if (callback) callback(); 
                  }
                );
              });
            } else if (callback) callback();
          },
          changeAltitude(value, callback) {
            if (this.flying) {
              addCommand(next => {
                updateDroneSound(basePlaybackRate + 1.0);
                const startAltitude = this.altitude;
                const minAltitude = getSafeAltitudeAt(this.mesh.position.x, this.mesh.position.z);
                const targetAltitude = Math.max(startAltitude + value, minAltitude);
                animateProperty(
                  val => {
                    const clampedAltitude = Math.max(val, minAltitude);
                    this.mesh.position.y = clampedAltitude;
                    this.altitude = clampedAltitude;
                    updateStatus();
                  },
                  startAltitude, targetAltitude, Math.abs(targetAltitude - startAltitude) * 50,
                  () => {
                    updateDroneSound(basePlaybackRate);
                    next();
                    if (callback) callback();
                  }
                );
              });
            } else if (callback) callback();
          },          
          setAngle(angle, callback) {
            if (this.flying) {
              addCommand(next => {
                updateDroneSound(basePlaybackRate + 1.0);

                const normalizedTarget = ((angle % 360) + 360) % 360;
                const normalizedCurrent = ((-this.direction % 360) + 360) % 360;

                let delta = normalizedTarget - normalizedCurrent;

                if (delta > 180) delta -= 360;
                if (delta < -180) delta += 360;

                const startDirection = this.direction;

                animateProperty(
                  val => {
                    this.direction = startDirection - delta * val;
                    this.mesh.rotation.y = THREE.MathUtils.degToRad(this.direction);
                    updateStatus();
                  },
                  0, 1, 500,
                  () => {
                    updateDroneSound(basePlaybackRate);
                    next();
                    if (callback) callback();
                  }
                );
              });
            } else if (callback) callback();
          },
          changeAngle(angle, callback) {
            if (this.flying) {
              addCommand(next => {
                updateDroneSound(basePlaybackRate + 1.0);
                const startDir = this.direction;
                animateProperty(
                  val => {
                    let newDirection = startDir - angle * val;
                    this.direction = ((newDirection % 360) + 360) % 360; 
                    this.mesh.rotation.y = THREE.MathUtils.degToRad(this.direction);
                    updateStatus();
                  },
                  0, 1, 500,
                  () => { updateDroneSound(basePlaybackRate); next(); if(callback) callback();}
                );
              });
            } else if (callback) callback();
          },
          slide(distance, callback) {
            if (this.flying) {
              addCommand(next => {
                updateDroneSound(basePlaybackRate + 1.0);
                const startX = this.mesh.position.x;
                const startZ = this.mesh.position.z;
                const rad = THREE.MathUtils.degToRad(this.direction );
                this.mesh.rotation.y = THREE.MathUtils.degToRad(this.direction);
                animateProperty(
                  val => { 
                    this.mesh.rotation.x = THREE.MathUtils.degToRad(-10 * Math.sign(distance) ) * val;
                  },
                  0, 1, 100, 
                  () => { 
                    animateProperty(
                      val => {
                        this.mesh.position.x = startX - Math.sin(rad) * distance * val;
                        this.mesh.position.z = startZ - Math.cos(rad) * distance * val;
                        updateStatus();
                      },
                      0, 1, Math.abs(distance) * 50,
                      () => {
                        animateProperty(
                          val => { 
                            this.mesh.rotation.x = THREE.MathUtils.degToRad(20 * Math.sign(distance)) * val;
                          },
                          0, 1, 100, 
                          () => {
                            updateDroneSound(basePlaybackRate);
                            animateProperty(
                              val => { 
                                this.mesh.rotation.x = THREE.MathUtils.degToRad(-10 * Math.sign(distance)) * (1-val);
                              },
                              0, 1, 100, 
                              () => { next(); if (callback) callback(); }
                            );
                          }
                        );
                      }
                    );    
                  }
                );
              });
            } else if (callback) callback();
          },
          walk(distance, callback) {
            if (this.flying) {
              addCommand(next => {
                updateDroneSound(basePlaybackRate + 1.0);
                const startX = this.mesh.position.x;
                const startZ = this.mesh.position.z;
                const rad = THREE.MathUtils.degToRad(this.direction-90);
                if (this.speed > 10.0) this.speed= 10.0;
                if (this.speed < 0.0) this.speed= 0.0;
                animateProperty(
                  val => { 
                    this.mesh.rotation.z = THREE.MathUtils.degToRad(10 * Math.sign(distance)) * val;
                  },
                  0, 1, 100, 
                  () => { 
                    animateProperty(
                      val => {
                        this.mesh.position.x = startX + Math.sin(rad) * distance * val;
                        this.mesh.position.z = startZ + Math.cos(rad) * distance * val;
                        updateStatus();
                      },
                      0, 1, Math.abs(distance) * 50 / this.speed,
                      () => {
                        animateProperty(
                          val => { 
                            this.mesh.rotation.z = THREE.MathUtils.degToRad(-20 * Math.sign(distance)) * val;
                          },
                          0, 1, 100, 
                          () => {
                            updateDroneSound(basePlaybackRate);
                            animateProperty(
                              val => { 
                                this.mesh.rotation.z = THREE.MathUtils.degToRad(10 * Math.sign(distance)) * (1-val);
                              },
                              0, 1, 100, 
                              () => { next(); if (callback) callback(); }
                            );
                          }
                        );
                      }
                    );    
                  }
                );
              });
            } else if (callback) callback();
          }
        }
        setupStatusInputs();
      }
      
let smokeTrail = [];

function createSmokeParticle(position) {
  const geometry = new THREE.SphereGeometry(0.15, 8, 8);
  const material = new THREE.MeshBasicMaterial({
    color: 0x888888,
    transparent: true,
    opacity: 0.5,
    depthWrite: false,
  });
  const sphere = new THREE.Mesh(geometry, material);
  sphere.position.copy(position);
  scene.add(sphere);
  smokeTrail.push(sphere);

  // Limit number of smoke particles for performance
  //if (smokeTrail.length > 200) {
  //  const old = smokeTrail.shift();
  //  scene.remove(old);
  //}
}
                          
      
      // --- Updating the status panel ---
      const updateStatus = () => {
        document.getElementById('x').value = -drone.mesh.position.z.toFixed(2);
        document.getElementById('z').value = -drone.mesh.position.x.toFixed(2);
        document.getElementById('altitude').value = drone.altitude.toFixed(2);
        document.getElementById('direction').value = ((-drone.direction.toFixed(0) % 360) + 360) % 360 ;
        document.getElementById('flightStatus').innerText = drone.flying ? "In Flight" : "On Ground";
      };

      const setupStatusInputs = () => {
        document.getElementById('z').addEventListener('change', e => {
          drone.mesh.position.x = -parseFloat(e.target.value);
          enforceTerrainCollision();
        }, { passive: true });
        document.getElementById('x').addEventListener('change', e => {
          drone.mesh.position.z = -parseFloat(e.target.value);
          enforceTerrainCollision();
        }, { passive: true });
        document.getElementById('altitude').addEventListener('change', e => {
          drone.mesh.position.y = parseFloat(e.target.value);
          enforceTerrainCollision();
        }, { passive: true });
        document.getElementById('direction').addEventListener('change', e => {
          drone.mesh.rotation.y = THREE.MathUtils.degToRad( parseFloat(-e.target.value));        
        }, { passive: true });
      };

      // --- Animation loop ---
      const animate = () => {
        requestAnimationFrame(animate);
        if (drone && drone.mesh) {
          enforceTerrainCollision();
          const offset = cameraOffset.clone();
          const spherical = new THREE.Spherical().setFromVector3(offset);
          spherical.theta += cameraAngle.x;
          spherical.phi += cameraAngle.y;
          spherical.phi = Math.max(THREE.MathUtils.degToRad(10), Math.min(THREE.MathUtils.degToRad(85), spherical.phi));
          offset.setFromSpherical(spherical);
          camera.position.copy(drone.mesh.position).add(offset);
          camera.lookAt(drone.mesh.position);
          if (drone.smoke){
            if (drone.flying && drone.mesh) {
              const pos = drone.mesh.position.clone();
              createSmokeParticle(pos);
            }
          }
        }
        renderer.render(scene, camera);
      };

      // --- Scene reset ---
        const resetCameraView = () => {
          cameraAngle.x = Math.PI / 2;
          cameraAngle.y = 0;
          cameraOffset.copy(defaultCameraOffset);
          camera.position.set(4, 0, 4);
        };

        const resetScene = () => {
          const startAltitude = getGroundHeightAt(0, 0) + collisionPadding;
          drone.mesh.position.set(0, startAltitude, 0);
          drone.mesh.rotation.y = 0;
          drone.altitude = startAltitude;
          drone.direction = 0;
          drone.smoke = 0; 
        resetCameraView();
          clearInterval(drone.propellerInterval); 
          drone.flying = false;
          updateStatus();

        smokeTrail.forEach(p => scene.remove(p));
        smokeTrail = [];
      };

      // --- Menu button handlers ---
      document.getElementById('newBtn').addEventListener('click', () => {
        workspace.clear();
        setTimeout(() => {
          const xml_text = `<xml xmlns="https://developers.google.com/blockly/xml">
            <block type="start_block" x="10" y="10"></block>
          </xml>`;
          const parser = new DOMParser();
          const xml = parser.parseFromString(xml_text, 'text/xml');
          Blockly.Xml.domToWorkspace(xml.documentElement, workspace);
        }, 10);
      });
      document.getElementById('saveBtn').addEventListener('click', () => {
        const xml = Blockly.Xml.workspaceToDom(workspace);
        const xml_text = Blockly.Xml.domToPrettyText(xml);
        const blob = new Blob([xml_text], { type: 'text/xml' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'drone_code.xml';
        a.click();
      }, { passive: true });
      document.getElementById('loadBtn').addEventListener('click', () => {
        document.getElementById('fileInput').click();
      });
      document.getElementById('fileInput').addEventListener('change', event => {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = e => {
          const xml_text = e.target.result;
          const parser = new DOMParser();
          const xml = parser.parseFromString(xml_text, 'text/xml');
          workspace.clear();
          Blockly.Xml.domToWorkspace(xml.documentElement, workspace);
        };
        reader.readAsText(file);
      }, { passive: true });
      document.getElementById('runBtn').addEventListener('click', () => {
        if (run==false){
          initAudio();
          document.getElementById("stopBtn").disabled = false;
          document.getElementById("runBtn").disabled = true;
          resetScene();
          var code = Blockly.JavaScript.workspaceToCode(workspace);
          delay = 100;
          run=true;
          code=code.replace(/\bfunction\b/g, 'async function');
          code=code.replace(/\n/g, ';\n  await new Promise(r => setTimeout(r, delay));delay=10;if(run!=true)return;');
          var wrappedCode = `
            async function _run() {
              ${code}
              document.getElementById('stopBtn').click();
            }
            _run();
          `;
          console.log(wrappedCode);
          eval(wrappedCode);
        }
      }, { passive: true });
      document.getElementById('stopBtn').addEventListener('click', () => {
        if (run==true){
          document.getElementById("runBtn").disabled = false;
          commandQueue.length = 0;
          run=false;
          stopDroneSound();
          clearInterval(drone.propellerInterval);
        }
        else{
          setTimeout(resetScene,delay);       
          document.getElementById("stopBtn").disabled = true;
        }
      }, { passive: true });
                
      // --- Divider management for resizing ---
      let fullScreen = false;
      document.getElementById('toggleWebglBtn').addEventListener('click', () => {
        const leftPanel = document.getElementById('leftPanel');
        const divider = document.getElementById('divider');
        const rightPanel = document.getElementById('rightPanel');
        const statusPanel = document.getElementById('statusPanel');
          
        if (!fullScreen) {
          leftPanel.style.display = 'none';
          divider.style.display = 'none';
          rightPanel.style.width = '100%';
          statusPanel.style.display = 'none';
          document.getElementById('toggleWebglBtn').innerText = "ðŸ——";
        } else {
          leftPanel.style.display = '';
          divider.style.display = '';
          rightPanel.style.width = '';
          statusPanel.style.display = '';
          document.getElementById('toggleWebglBtn').innerText = "ðŸ—–";
        }
        fullScreen = !fullScreen;
        updateWebGLCanvas();
      }, { passive: true });

      divider.addEventListener('mousedown', () => { isResizing = true; });
      document.addEventListener('mousemove', e => {
        if (!isResizing) return;
        const containerOffsetLeft = container.offsetLeft;
        let pointerX = e.clientX - containerOffsetLeft;
        const minWidth = 200;
        const maxWidth = container.clientWidth - 200;
        pointerX = Math.max(minWidth, Math.min(pointerX, maxWidth));
        leftPanel.style.width = pointerX + "px";
        Blockly.svgResize(workspace);
        updateWebGLCanvas();
      }, { passive: true });
      document.addEventListener('mouseup', () => { isResizing = false; }, { passive: true });
        
      // --- Localization ---
      function loadLanguageFile(lang, callback) {
        var script = document.createElement('script');
        script.src = 'libs/Msg/' + lang + '.js';
        script.onload = function() {
          if (callback) callback();
        };
        document.head.appendChild(script);
      }

      function updateLanguage(selectedLang) {
        document.getElementById('newBtn').innerText = Blockly.Msg.BKY_NEW || "New";
        document.getElementById('loadBtn').innerText = Blockly.Msg.BKY_LOAD || "Load";
        document.getElementById('saveBtn').innerText = Blockly.Msg.BKY_SAVE || "Save";
        Blockly.setLocale(selectedLang);
        localStorage.setItem('selectedLanguage', selectedLang);
        defineCustomBlocks();
        if(workspace){
          workspace.dispose();
        }
        document.getElementById('blocklyDiv').innerText='';
        initBlockly();
      }

      document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedLang = this.value;
        loadLanguageFile(selectedLang, function() {
          updateLanguage(selectedLang);
        });
      }, { passive: true });
      
      document.getElementById('scenarioSelect').addEventListener('change', function() {
        const selectedScenario = this.value;
        loadScenario(selectedScenario);
        resetCameraView();
      });
              
      function loadScenarioList() {
        fetch('backgrounds/list.json')
          .then(response => response.json())
          .then(data => {
            const scenarioSelect = document.getElementById('scenarioSelect');
            scenarioSelect.innerHTML = '<option value="">Default</option>';
            data.forEach(scenario => {
              const option = document.createElement('option');
              option.value = scenario.file;
              option.text = scenario.name;
              scenarioSelect.appendChild(option);
            });
          })
          .catch(err => console.error('Errore caricando la lista degli scenari:', err));
      }

      window.onload = function() {
          defineCustomBlocks();
          initBlockly();
          initThree();
          updateWebGLCanvas();
          animate();
          var savedLang = localStorage.getItem('selectedLanguage') || 'en';
          document.getElementById('languageSelect').value = savedLang;
          loadLanguageFile(savedLang, function() {
            updateLanguage(savedLang);
          });
          loadScenarioList();
      };
    </script>
  </body>
</html>
